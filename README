Both programs are in Ruby.

zsh> ruby -v
ruby 1.8.7 (2010-06-23 patchlevel 299) [i686-linux]
zsh> uname
Linux

USAGE:
ruby spellChecker.rb
ruby spellGenerator.rb [nb_words]
ruby spellGenerator.rb [nb_words] | ruby spellChecker.rb

DESCRIPTION:
- The SpellChecker program works as a promt. Write wrong words and let the program correct them.
- The SpellGenerator program generates [nb_words] wrong words.
  OPTIONS
	nb_words	How many words you want to generates.
			By default nb_words has the value of 100.

You can pipe spellGenerator's output to spellChecker program to automaticly correct words.
SpellChecker program will automatically stop whenever it find a '0', ctrl + c or '\0'.

INFORMATONS:
To find the correct word :
1- I first try the word,
2- If no match, I build a regex base on the wrong word and use it to find candidates in the dictionary,
5- If there is more than one candidate, I calculate the number of opperations needed to find the word in my candidates list and return the lowest one.

COMPLEXITY:
n = the length of the wrong word
m = the number of words in my dictionnary

1- Put the dictionnary in memory : O(m)
2- Create a regex base on the wrong word : O(n)
--- START SEARCHING ---
3- Foreach words in the dictionnary, match with the regex,
4- If more than one candidate, calculate the Levenshtein distance.
--- END ---

Complexity of part 3 :

Depends of the implementation of the regex solver. However, the more precise if the regex, the lowest
complexity i'll have. In this case, the better case would be O(m)
(the implementation of Knuth-Morris-Pratt algorithm in regex give O(m)).

Complexity of part 4 :

p = length of string 1
k = length of string 2
Levenshtein distance is in O(pk) at runtime. How ever my implementation is in O(p) in memory.
The instruction tell me that if there is more that one candidates, i can choose one of them
in the way i want. Since Levenshtein complexity will be INSIGNIFICANT, i chose to use it to have
better results.

Then the Complexity when searching of this program should be O(m),
with m the number of words in my dictionnary.

This technique will resolve 100% of wrong words generated by my spellGenerator.

WHY RUBY?
Good:
- Sexy language I wanted to practice,
- Fast development,
- Well documented.

Bad:
- Slower than C language,
- Not really design for scripting.

By Pierre-Louis Gottfrois
